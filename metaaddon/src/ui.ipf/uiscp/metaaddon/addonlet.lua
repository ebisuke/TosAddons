--metaaddon_addonlet
local addonName = "metaaddon"
local addonNameLower = string.lower(addonName)
--作者名
local author = "ebisuke"

--アドオン内で使用する領域を作成。以下、ファイル内のスコープではグローバル変数gでアクセス可
_G["ADDONS"] = _G["ADDONS"] or {}
_G["ADDONS"][author] = _G["ADDONS"][author] or {}
_G["ADDONS"][author][addonName] = _G["ADDONS"][author][addonName] or {}
local g = _G["ADDONS"][author][addonName]
g.cls = g.cls or {}
g.cls.MAAddonlet = function(addonletName, title)
    local self = {
        addonletName = "",
        title = "",
        nodes = {},
        _isTemporary = false,
        _className = "MAAddonlet",
        scrollOffset = {x = 0, y = 0},
        zoom = 1,
        selected = {},

        getDependencies = function(self)
            local dependencies = {}
            for k,v in pairs(self.nodes) do
                if v:instanceOf(g.cls.MADependencyBaseNode()) then
                    dependencies[#dependencies+1] = v:getDependency()
                end
            end
            return dependencies
        end,
        initImpl = function(self)
            self.addonletName = addonletName
            self.title = title
        end,
        clear = function(self)
            self.nodes = {}
            self.streams = {}
            self.selected = {}
        end,
        insertNodes = function(self, lists)
            for i, node in ipairs(lists) do
                table.insert(self.nodes, node)
            end
        end,
        insertAndCloneNodes = function(self, lists)
            for i, node in ipairs(lists) do
                table.insert(self.nodes, node:clone())
            end
        end,
        compile = function(self)
            local topmosts = self:findTopMosts()
            local tbl = {}
            tbl[#tbl+1]=
            [[
                -- generated by metaaddon
                local g=METAADDON_CONTEXT[']] .. self.addonletName .. [[']
                local definition=g.definition
                local datatable=g.datatable
                local context=g.context
                local funcs=g.funcs
                local topmost=g.topmost
                local indata=g.indata
                local outdata=g.outdata
                local state={}
                local variables={}
                local temp={}
                local EMPTY={_METAADDONEMPTY=true}
                local NONE={_METAADDONEMPTY=true}
                local keepin=false
                local function getFlags(flag)
                    return  METAADDON_GET_FLAGS(flag) 
                end
                local function keepInData()
                    keepin=true
                end
            ]]

            for i, node in pairs(self.nodes) do
                tbl[#tbl + 1] = "-- " .. node._className
                tbl[#tbl + 1] = "temp={['name']='".. node._className.."',['in']={},['out']={},['next']={}}"
                for k, gate in pairs(node:getInlets()) do
                    local streams = gate:getStreams()
                    if g.fn.len(streams) == 0 then
                        tbl[#tbl + 1] = string.format("temp['in'][#temp['in']+1]=NONE")
                    else
                        for kkk, vvv in pairs(streams) do
                            tbl[#tbl + 1] = string.format("temp['in'][#temp['in']+1]='%s'", vvv:getID())
                        end

                    end
                end
                for k, gate in pairs(node:getOutlets()) do
                    local streams = gate:getStreams()
                    if g.fn.len(streams) == 0 then
                        tbl[#tbl + 1] = string.format("temp['out'][#temp['out']+1]=NONE")
                       
                    
                    else
                        tbl[#tbl + 1] = string.format("temp['out'][%d]={}",k,k)
                        tbl[#tbl + 1] = string.format("temp['next'][%d]={}",k,k)
                        
                        for kkk, vvv in pairs(streams) do
                            tbl[#tbl + 1] = string.format("temp['out'][%d][#temp['out'][%d]+1]='%s'",k,k, vvv:getID())
                            tbl[#tbl + 1] =
                                string.format("temp['next'][%d][#temp['next'][%d]+1]='%s'",k ,k, vvv.destinationGate.ownerNode:getID())
                        end
                    end
                end

                tbl[#tbl + 1] = string.format("definition['%s']=temp", node:getID())
            end
            for i, node in pairs(self.nodes) do
                local str = node:compile(self)
                if str ~= "" then
                    table.insert(tbl, "funcs['" .. node:getID() .. "']=function(args) \n" .. str .. "\nend\n")
                end
            end
            for i, node in pairs(topmosts) do
                
                table.insert(tbl, "topmost['" .. node:getID() .. "']='" .. node:getID() .. "'")
            
            end
         
            tbl[#tbl + 1] =
                [[
                g.fn= function()
                    local ran={}
                    local toremove={}
                    local concated={}
                    local nexts={}
                    for k,v in pairs(topmost) do
                        concated[k]=v
                    end
                    for k,v in pairs(context) do
                        concated[k]=v
                    end
                    for k,v in pairs(concated) do
                        ran[k]=v
                        local args={}
                        local complete=true
        
                        for kk,vv in pairs(definition[k]['in']) do
                            datatable[k]=datatable[k] or {}
                            if vv~=nil and vv~= NONE and datatable[k][vv]==nil then
                                complete=false
                                break
                            end
                            if vv~=nil and vv~=NONE then
                                args[#args+1]=datatable[k][vv]
                            else
                                args[#args+1]=NONE
                            end
                            
                        end
                
                    
                        if complete then
                            
                            
                            if funcs[k] then
                                keepin=false
                                local ret
                                state[k]=state[k] or {}

                                local tmp=function()
                                    local _ENV=setmetatable(state[k],{__index=_G})
                                    ret=table.pack(funcs[k](args))
                                end
                                tmp()
                                if keepin then
                                    keepin=false
                                else
                                    for kk,vv in pairs(definition[k]['in']) do
                                        toremove[k]=toremove[k] or {}
                                        toremove[k][vv]=true
                                    end
                                end
                                context[k]=nil
                                
                                for retindex,retvalue in ipairs(ret) do
                                    
                                    
                                    if definition[k]['out'][retindex] and #definition[k]['out'][retindex] > 0 then
                                        
                                        for outletindex,_ in ipairs(definition[k]['next']) do
                                            for _,nextnodeid in ipairs(definition[k]['next'][outletindex]) do
                                                if nextnodeid then
                                                    nexts[nextnodeid]=true
                                                    datatable[nextnodeid]=datatable[nextnodeid] or {}
                                                    for outindex,_ in   ipairs(definition[k]['out'][retindex]) do
                                                        
                                                        datatable[nextnodeid][definition[k]['out'][retindex][outindex] ]=retvalue
                                                        
                                                    end
                                                end
                                            end
                                        end
                                        
                                    end
                                    
                                end
                            else
                                for kk,vv in pairs(definition[k]['in']) do
                                    toremove[k]=toremove[k] or {}
                                    toremove[k][vv]=true
                                    
                                end
                                context[k]=nil
                            end
                        else
                            
                        end
                    end
                    for nextnodeid,v in pairs(nexts) do
                        
                        context[nextnodeid]=nextnodeid
                    end

                    for nodeid,__ in pairs(toremove) do
                        if  datatable[nodeid] then
                            for dataid,__ in pairs(toremove[nodeid]) do
                                datatable[nodeid][dataid]=nil
                            end
                        end
                    end
                end

                return g.fn
            ]]
            
            return table.concat(tbl, "\n")
        end,
        findRequiresStream = function(self)
            --find topmost
            local topmostnodes = {}
            local watched = {}

            for k, v in ipairs(self.nodes) do
                watched[v] = true
                local top = true
                if v:getInlets() then
                    local look = v
                    repeat
                        watched[look:getID()] = look
                        for kk, gate in ipairs(v:getInlets()) do
                            local streams = gate:getStreams()
                            for kkk, vvv in ipairs(streams) do
                                local src = vvv.sourceGate
                                if src ~= nil then
                                    look = src.ownerNode
                                end
                                goto continue
                            end
                        end
                        topmostnodes[v:getID()] = v
                        ::continue::
                    until look == nil or watched[look]
                end
            end
            return topmostnodes
        end,
        findTopMosts = function(self)
            --find topmost
            local topmostnodes = {}
            local watched = {}

            for k, v in pairs(self.nodes) do
                watched[v:getID()] = true
                local top = true
                if v:getInlets() and g.fn.len(v:getInlets()) > 0 then
                    local look = v
                    repeat
                        watched[look:getID()] = look
                        g.fn.dbgout("looking for " .. look._className)
                        for kk, gate in pairs(v:getInlets()) do
                            local streams = gate:getStreams()
                            for kkk, vvv in pairs(streams) do
                                local src = vvv.sourceGate
                                if src ~= nil then
                                    look = src.ownerNode
                                    g.fn.dbgout("parent found " .. v._className)
                                    goto continue
                                else
                                    g.fn.errout("sourceGate is nil " .. v._className)
                                end
                            end
                        end
                        topmostnodes[v:getID()] = v
                        ::continue::
                    until look == nil or watched[look:getID()]
                else
                    g.fn.dbgout("not inlets " .. v._className)
                    topmostnodes[v:getID()] = v
                end
            end
            return topmostnodes
        end,
        hitTestByBox = function(self, left, top, right, bottom)
            local hits = {}
            for id, node in pairs(self.nodes) do
                if node:hitTestBox(left, top, right, bottom) then
                    hits[node:getID()] = node
                end
                if node.getChildren then
                    for _, v in pairs(node:getChildren()) do
                        if v:hitTestBox(left, top, right, bottom) then
                            hits[node:getID()] = v
                        end
                    end
                end
            end

            return hits
        end,
        selectByBox = function(self, left, top, right, bottom, includeGate)
            if keyboard.IsKeyPressed("LSHIFT") == 1 then
            else
                self.selected = {}
            end
            for id, node in pairs(self.nodes) do
                if node:hitTestBox(left, top, right, bottom) then
                    g.fn.dbgout("Select node:" .. node._name)
                    self.selected[node:getID()] = node
                end
                if node.getChildren then
                    for _, v in pairs(node:getChildren()) do
                        if includeGate or not v:instanceOf(g.cls.MAGate()) then
                            if v:hitTestBox(left, top, right, bottom) then
                                self.selected[node:getID()] = v
                            end
                        end
                    end
                end
            end
        end,
        addNode = function(self, node)
            self.nodes[node:getID()] = node
        end,
        addStream = function(self, stream)
            self.streams[stream:getID()] = stream
        end,
        removeNode = function(self, node)
            for i, v in pairs(self.nodes) do
                if v:getID() == node:getID() then
                    self.nodes[i] = nil
                    break
                end
            end
        end,
        render = function(self, gbox)
            for id, node in pairs(self.nodes) do
                node:render(self, gbox, self.scrollOffset, self.zoom)
            end
        end,
        calculateBoundingBox = function(self)
            local left, top, right, bottom = 0, 0, 0, 0
            for id, node in pairs(self.nodes) do
                local bbox = node:calculateBoundingBox()
                left = math.min(left, bbox.left)
                top = math.min(top, bbox.top)
                right = math.max(right, bbox.right)
                bottom = math.max(bottom, bbox.bottom)
            end
            return {left = left, top = top, right = right, bottom = bottom}
        end,
        isSelected = function(self, node)
            for i, n in pairs(self.selected) do
                if n == node then
                    return true
                end
            end
            return false
        end,
        isTemporary = function(self)
            return self._isTemporary
        end,
        assignImpl = function(self, obj)
            self._supers["MASerializable"].assignImpl(self, obj)
            self.addonletName = obj.addonletName
            self.title = obj.title
            self.nodes = {}
            for i, v in pairs(obj.nodes) do
                self.nodes[#self.nodes + 1] = v:clone()
            end
            self.streams = obj.streams
            self.selected = obj.selected
            self.scrollOffset = obj.scrollOffset
            self.zoom = obj.zoom
        end
    }
    local obj = g.fn.inherit(self, g.cls.MASerializable())

    return obj
end
